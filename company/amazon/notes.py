Pending


1. Binary Serialize Deserialize - Check iterative approach
2. Matrix Median - Solve using binary search
3. Max Distance - Implement O(n) approach
4. Sorted Array to BST - Try iterative version
5. kth smallest element - What if BST is modified
6. Valid BST - Check for iterative approach
7. Single number 2 - Check complicated bit approach
8. Random pointer deep copy - Check O(1) and single pass approach
9. Atoi - Check solution with direct string converstion to integer, currently converted to integer directly. 
10. Reverse words - O(1) space complexity
11. Rainwater trapped - Check Stack and 2 pointer approach, solved with dp.
12. Clone graph - Check DFS iterative
13. Balanced Tree - Check Iterative approach
14. closest k points - QuickSelect/Divide conquer approach
15. Connected Graphs - Union approach
16. Meeting room - Checkout priority queue
17. Word ladder - Check out middle way approach

16. Largest number, kth frequent element - Comparison sort need to understand a bit more __lt__
17. nearest k element - revise

Interesting

1. Count 1bits -> hamming approach/ pattern/ lsb
2. Generate paranthese -> Time complexity of catalan2. Generate paranthese -> Time complexity of catalan
3. Compare version -> to remove leading zeros, convert string to number
4. Reverse words -> How to implement O(1) reversal without using lists?
5. Delete half node -> Interesting way to approach children, root.left = traverse(root.left) instead of root.left.left checks
6. Median of stream -> Max heap should be greater in size than minheap, whenever max_heap - min_heap > 1, rebalance
